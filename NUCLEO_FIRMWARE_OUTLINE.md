# NUCLEO-H7S3L8 Firmware Architecture Outline

## Overview

This document outlines the firmware architecture for the **NUCLEO-H7S3L8** (STM32H7S3L8H6) to receive direct step commands via binary protocol and control the Delta Robot's stepper motors. The firmware will be developed using STM32 HAL libraries and the LwIP TCP/IP stack.

## Platform Specifications

- **Microcontroller**: STM32H7S3L8H6
- **CPU**: ARM Cortex-M7F @ 280 MHz
- **Memory**: 2MB Flash, 256KB SRAM
- **Ethernet**: Built-in IEEE-802.3-2002 compliant PHY
- **Development**: STM32CubeIDE, STM32CubeMX, HAL Library
- **Networking**: LwIP (Lightweight IP) stack

## Core Components

### 1. Ethernet Communication Layer (LwIP)

**Purpose**: Handle TCP/IP connections and packet communication

**Responsibilities**:
- Initialize LwIP stack
- Configure Ethernet PHY
- Accept incoming TCP connections from PC
- Receive binary packets over TCP
- Send response packets
- Handle connection timeouts
- Manage keep-alive (ping/pong)

**Key Functions**:
```c
void MX_LWIP_Init(void);  // Initialize LwIP (generated by STM32CubeMX)
void ethernet_init(void);
void tcp_server_init(void);
void handle_tcp_connection(void);
bool packet_available(void);
bool receive_packet(uint8_t* buffer, size_t* length);
bool send_packet(const uint8_t* buffer, size_t length);
```

**LwIP Configuration**:
- TCP server on port 8080
- Non-blocking socket operations
- Receive buffer: 512 bytes
- Send buffer: 512 bytes
- Connection timeout: 10 seconds

---

### 2. Packet Parser

**Purpose**: Parse incoming binary packets according to protocol

**Responsibilities**:
- Validate packet structure (header, length, checksum)
- Extract packet type and payload
- Route to appropriate command handler
- Handle malformed packets
- Encode response packets

**Key Functions**:
```c
bool parse_packet(const uint8_t* data, size_t length, packet_t* packet);
bool verify_checksum(const uint8_t* data, size_t length);
packet_type_t get_packet_type(const packet_t* packet);
bool extract_payload(const packet_t* packet, void* dest);
bool encode_response(packet_t* response, uint8_t* buffer, size_t* length);
```

**Data Structures**:
```c
typedef enum {
    CMD_MOVE_ABS = 0x01,
    CMD_MOVE_REL = 0x02,
    CMD_SET_SPEED = 0x03,
    // ... etc
} packet_type_t;

typedef struct {
    packet_type_t type;
    uint16_t payload_length;
    uint8_t* payload;
    uint8_t checksum;
} packet_t;
```

---

### 3. Command Handler

**Purpose**: Execute commands received from PC

**Responsibilities**:
- Process each command type
- Validate parameters
- Queue movements if needed
- Send appropriate responses
- Handle errors gracefully

**Command Handlers**:
```c
void handle_move_absolute(const packet_t* packet);
void handle_move_relative(const packet_t* packet);
void handle_set_speed(const packet_t* packet);
void handle_set_acceleration(const packet_t* packet);
void handle_enable(const packet_t* packet);
void handle_stop(const packet_t* packet);
void handle_home(const packet_t* packet);
void handle_set_position(const packet_t* packet);
void handle_config(const packet_t* packet);
void handle_ping(const packet_t* packet);
void handle_request_status(const packet_t* packet);
void handle_sequence(const packet_t* packet);  // CMD_SEQUENCE
```

---

### 4. Motor Controller

**Purpose**: Control 3 stepper motors with coordinated motion

**Responsibilities**:
- Initialize stepper motors (GPIO, timers)
- Execute coordinated movements
- Generate step pulses using timers
- Manage acceleration/deceleration
- Track motor positions
- Handle enable/disable

**Key Functions**:
```c
void motor_init(void);
void motor_move_to_absolute(const int32_t positions[3]);
void motor_move_relative(const int32_t deltas[3]);
void motor_set_speed(int motor, float speed);
void motor_set_acceleration(int motor, float accel);
void motor_enable(bool enable);
void motor_stop(void);
bool motor_is_moving(void);
void motor_update(void);  // Call in main loop
```

**Implementation Options**:

**Option A: Timer-based Step Generation**
- Use HAL timers in PWM mode
- Configure timer frequency for step rate
- Use timer interrupts for step pulses
- Advantages: Precise timing, hardware-accelerated

**Option B: GPIO-based with Software Timing**
- Use GPIO toggling with software delays
- Simpler but less precise
- Use HAL delay functions or systick

**Option C: DMA-based Step Generation**
- Use DMA to transfer step patterns
- Most efficient for high-speed operation
- More complex implementation

**Recommended**: Option A (Timer-based) for precise control with good performance.

**Motor State Structure**:
```c
typedef struct {
    int32_t current_position;  // Steps from home
    int32_t target_position;   // Target steps
    float max_speed;           // Steps per second
    float acceleration;         // Steps per second squared
    bool enabled;              // Motor enabled
    bool moving;               // Currently moving
    TIM_HandleTypeDef* step_timer;
    GPIO_TypeDef* step_port;
    uint16_t step_pin;
    GPIO_TypeDef* dir_port;
    uint16_t dir_pin;
    GPIO_TypeDef* enable_port;
    uint16_t enable_pin;
} motor_state_t;
```

---

### 5. Status Reporter

**Purpose**: Send periodic status updates to PC

**Responsibilities**:
- Collect current motor positions
- Check if motors are moving
- Send status packets periodically
- Respond to status requests

**Key Functions**:
```c
void status_send_update(void);
void status_collect(status_info_t* status);
uint32_t status_get_last_time(void);
```

**Status Frequency**:
- Every 100ms during movement
- Immediately when movement completes
- On request (CMD_REQUEST_STATUS)

**Status Structure**:
```c
typedef struct {
    int32_t positions[3];
    bool moving[3];
    bool enabled;
} status_info_t;
```

---

### 6. Homing System

**Purpose**: Home motors to known reference positions

**Responsibilities**:
- Move motors until end-stops trigger
- Set position to zero after homing
- Report homing completion
- Handle homing errors

**Key Functions**:
```c
void homing_start(void);
void homing_update(void);  // Call in main loop during homing
bool homing_is_active(void);
bool homing_is_complete(void);
```

**Implementation**:
- Use GPIO interrupts for end-stop detection
- Move motors slowly until end-stop triggers
- Set motor position to zero after homing
- Send RESP_HOMED packet when complete

---

### 7. Sequence Executor

**Purpose**: Execute waypoint sequences from CMD_SEQUENCE packets

**Responsibilities**:
- Store received waypoint sequence
- Execute waypoints sequentially
- Calculate motor speeds from durations
- Interpolate between waypoints
- Report progress

**Key Functions**:
```c
void sequence_store(const packet_t* packet);
void sequence_execute_next(void);
bool sequence_is_active(void);
void sequence_calculate_speeds(void);
```

**Sequence Storage**:
```c
typedef struct {
    int32_t step_positions[3];
    uint16_t duration_ms;  // Time to reach this waypoint
} waypoint_t;

typedef struct {
    waypoint_t waypoints[255];  // Max 255 waypoints
    uint8_t count;
    uint8_t current_index;
    bool active;
} sequence_t;
```

---

## State Machine

### Motor States

```
DISABLED → ENABLED → MOVING → STOPPED → DISABLED
    ↑                              ↓
    └──────────────────────────────┘
```

### System States

```
INIT → IDLE → MOVING → IDLE
  ↓      ↓       ↓
ERROR  HOMING  ERROR
```

---

## Main Loop Structure

```c
int main(void) {
    // HAL initialization (generated by STM32CubeMX)
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_LWIP_Init();
    // ... other peripheral init
    
    // Custom initialization
    motor_init();
    tcp_server_init();
    
    uint32_t last_status_time = 0;
    uint32_t last_ping_time = 0;
    
    while (1) {
        // 1. Handle Ethernet communication
        MX_LWIP_Process();  // Process LwIP stack
        
        // 2. Parse incoming packets
        if (packet_available()) {
            packet_t packet;
            if (parse_packet(...)) {
                handle_command(&packet);
            }
        }
        
        // 3. Update motor controller
        motor_update();
        
        // 4. Update homing if active
        if (homing_is_active()) {
            homing_update();
        }
        
        // 5. Update sequence execution
        if (sequence_is_active()) {
            sequence_execute_next();
        }
        
        // 6. Send periodic status updates
        uint32_t now = HAL_GetTick();
        if (now - last_status_time > STATUS_INTERVAL) {
            status_send_update();
            last_status_time = now;
        }
        
        // 7. Handle keep-alive
        if (now - last_ping_time > PING_INTERVAL) {
            // Check connection health
            if (connection_lost()) {
                handle_timeout();
            }
            last_ping_time = now;
        }
    }
}
```

---

## Data Structures

### Motor State
```c
typedef struct {
    int32_t current_position;
    int32_t target_position;
    float max_speed;
    float acceleration;
    bool enabled;
    bool moving;
    TIM_HandleTypeDef* step_timer;
    // GPIO and pin definitions
} motor_state_t;
```

### System State
```c
typedef struct {
    motor_state_t motors[3];
    bool motors_enabled;
    bool homing;
    bool homed;
    uint32_t last_status_time;
    uint32_t last_ping_time;
    uint32_t last_ping_received;
    sequence_t current_sequence;
} system_state_t;
```

---

## Pin Configuration

Pin assignments will be configured via STM32CubeMX. Example configuration:

### Motor 1 (X-axis)
- STEP: PA0 (Timer 2 Channel 1, or GPIO)
- DIR: PA1 (GPIO Output)
- ENABLE: PA2 (GPIO Output)
- ENDSTOP: PA3 (GPIO Input with interrupt)

### Motor 2 (Y-axis)
- STEP: PB0 (Timer 3 Channel 1, or GPIO)
- DIR: PB1 (GPIO Output)
- ENABLE: PB2 (GPIO Output)
- ENDSTOP: PB3 (GPIO Input with interrupt)

### Motor 3 (Z-axis)
- STEP: PC0 (Timer 4 Channel 1, or GPIO)
- DIR: PC1 (GPIO Output)
- ENABLE: PC2 (GPIO Output)
- ENDSTOP: PC3 (GPIO Input with interrupt)

### Ethernet
- Automatically configured by STM32CubeMX when Ethernet is enabled
- Uses built-in PHY on NUCLEO-H7S3L8

**Note**: Actual pin assignments should be determined based on:
- Available GPIO pins
- Timer availability for step generation
- Board layout and routing
- User's specific requirements

---

## Configuration

### Default Settings
```c
#define DEFAULT_MAX_SPEED         1000.0f    // steps/sec
#define DEFAULT_ACCELERATION      500.0f     // steps/sec²
#define DEFAULT_MICROSTEPPING     16
#define STATUS_INTERVAL           100        // ms
#define PING_INTERVAL             5000       // ms
#define CONNECTION_TIMEOUT        10000      // ms
```

### Network Settings
```c
#define NUCLEO_IP_ADDR            "192.168.1.100"
#define NUCLEO_NETMASK            "255.255.255.0"
#define NUCLEO_GATEWAY            "192.168.1.1"
#define NUCLEO_PORT               8080
```

---

## STM32H7S3L8H6 Specific Implementation

### Timer Configuration for Step Generation

**Recommended Approach**: Use advanced timers (TIM1, TIM8) or general-purpose timers in PWM mode.

```c
// Example timer configuration for step generation
void timer_init_step_generation(TIM_HandleTypeDef* htim) {
    htim->Instance = TIM1;  // or TIM8, TIM2, etc.
    htim->Init.Prescaler = 0;
    htim->Init.CounterMode = TIM_COUNTERMODE_UP;
    htim->Init.Period = calculate_period_for_frequency(desired_step_rate);
    htim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    HAL_TIM_PWM_Init(htim);
}
```

### GPIO Configuration

```c
// GPIO initialization for motor control
void gpio_init_motor_control(void) {
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    
    // Enable GPIO clocks
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    
    // Configure STEP pins (if using GPIO, not timer)
    GPIO_InitStruct.Pin = GPIO_PIN_0;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    
    // Configure DIR pins
    // Configure ENABLE pins
    // Configure ENDSTOP pins with interrupts
}
```

### LwIP Configuration

LwIP configuration is handled by STM32CubeMX. Key settings:

- **TCP**: Enabled
- **UDP**: Optional (for future use)
- **DHCP**: Disabled (use static IP)
- **Memory pools**: Configured for packet buffers
- **Socket options**: Non-blocking mode

---

## Error Handling

### Error Types
- **Invalid Command**: Unknown packet type
- **Invalid Parameters**: Out of range values
- **Motors Not Enabled**: Command requires enabled motors
- **Movement Out of Range**: Target exceeds limits
- **Hardware Error**: Motor driver fault, etc.
- **Network Error**: Connection lost, timeout

### Error Response
```c
void send_error(error_code_t code, const char* message) {
    packet_t response;
    response.type = RESP_ERROR;
    // ... encode error packet
    send_packet(encode(&response));
}
```

---

## Synchronization

### Coordinated Movement

All 3 motors must move together. Implementation:

```c
void motor_move_coordinated(const int32_t positions[3]) {
    // Calculate required speeds for each motor to finish simultaneously
    float durations[3];
    calculate_durations(positions, durations);
    
    // Set speeds based on durations
    for (int i = 0; i < 3; i++) {
        float speed = calculate_speed_from_duration(durations[i]);
        motor_set_speed(i, speed);
    }
    
    // Start all motors simultaneously
    motor_start_all(positions);
}
```

### Movement Queue

If a new movement command arrives while motors are moving:
- **Option 1**: Reject (return error)
- **Option 2**: Queue (wait for current movement)
- **Option 3**: Abort and start new (emergency stop then move)

**Recommendation**: Option 2 (queue) for smooth operation, but limit queue depth to 3-5 commands.

---

## Performance Considerations

### Timing Constraints
- **Packet Processing**: < 10ms
- **Status Updates**: Every 100ms
- **Motor Updates**: Every iteration (non-blocking)
- **Keep-Alive**: Every 5 seconds
- **Step Generation**: Up to 100kHz (for high-speed motors)

### Memory Management
- **Packet Buffer**: 512 bytes (sufficient for all commands)
- **Movement Queue**: 3-5 commands max
- **Status Buffer**: 64 bytes
- **Sequence Buffer**: Up to 255 waypoints × 14 bytes = ~3.5KB

### Optimization
- Use DMA for step generation (if high-speed required)
- Use hardware timers for precise timing
- Minimize packet parsing overhead
- Use efficient data structures
- Leverage STM32H7's cache and memory hierarchy

---

## Development Workflow

### 1. Project Setup
1. Open STM32CubeMX
2. Create new project → Select STM32H7S3L8H6
3. Configure pins and peripherals
4. Generate code for STM32CubeIDE

### 2. Implementation Phases

**Phase 1: Basic Communication**
- LwIP Ethernet setup
- Packet parser
- Basic command handlers (enable, ping, status)

**Phase 2: Motor Control**
- GPIO initialization
- Timer configuration
- Individual motor movement
- Coordinated movement

**Phase 3: Advanced Features**
- Homing system
- Acceleration control
- Error handling
- Movement queue
- Sequence execution

**Phase 4: Optimization**
- Performance tuning
- Memory optimization
- Robustness improvements

### 3. Testing Strategy

**Unit Tests**:
- Packet encoding/decoding
- Command parsing
- Motor state management
- Status reporting

**Integration Tests**:
- Ethernet connection
- Command execution
- Coordinated movement
- Error handling

**Hardware Tests**:
- Individual motor control
- Coordinated movement
- Homing sequence
- Real-time performance
- Sequence execution

---

## Resources

- **STM32H7S3L8H6 Reference Manual**: STM32 documentation portal
- **STM32CubeH7**: HAL drivers and examples
- **LwIP Documentation**: Lightweight IP stack documentation
- **STM32CubeIDE**: Integrated development environment
- **STM32CubeMX**: Pin configuration and code generation tool

---

## Next Steps

1. **Set up development environment**
   - Install STM32CubeIDE
   - Install STM32CubeH7 package
   - Configure network settings

2. **Generate base project**
   - Use STM32CubeMX to configure hardware
   - Generate initial code

3. **Implement core components**
   - Start with packet parser
   - Add basic command handlers
   - Integrate motor control

4. **Test incrementally**
   - Test each component separately
   - Test with simulated hardware first
   - Test with real hardware

5. **Iterate and improve**
   - Add features as needed
   - Optimize performance
   - Handle edge cases
